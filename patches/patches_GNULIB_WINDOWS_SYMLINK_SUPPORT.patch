diff --git a/ChangeLog b/ChangeLog
index f386e9a579..252f302a59 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,118 +1,3 @@
-2023-08-14  Bruno Haible  <bruno@clisp.org>
-
-	readutmp, boot-time: Don't use __UT_* symbols (regression 2023-08-11).
-	* lib/readutmp.h (_GL_UT_USER_SIZE, _GL_UT_ID_SIZE, _GL_UT_LINE_SIZE,
-	_GL_UT_HOST_SIZE): New macros.
-	(struct utmpx32): Use them.
-
-2023-08-14  Bruno Haible  <bruno@clisp.org>
-
-	readutmp, boot-time: Fix build on 32-bit glibc (regression 2023-08-11).
-	Reported by Andreas Schwab <schwab@suse.de> in
-	<https://lists.gnu.org/archive/html/bug-gnulib/2023-08/msg00125.html>.
-	* lib/readutmp.h (struct utmpx32): Reference __UT_NAMESIZE, not
-	__UT_USERSIZE.
-
-2023-08-13  Bruno Haible  <bruno@clisp.org>
-
-	stdint: Fix configure test result with gcc 4.7 or 4.8.
-	* m4/stdint.m4 (gl_STDINT_H): Don't assume that _Generic works with
-	GCC versions < 4.9 with -std=gnu11.
-
-2023-08-13  Bruno Haible  <bruno@clisp.org>
-
-	Fix some test module descriptions.
-	* modules/boot-time-tests (Files): Add tests/macros.h.
-	* modules/dprintf-gnu-tests (Files): Likewise.
-	* modules/fclose-tests (Files): Likewise.
-	* modules/getcwd-tests (Files): Likewise.
-	* modules/lock-tests (Files): Likewise.
-	* modules/nullptr-c++-tests (Files): Likewise.
-	* modules/posix_spawn-tests (Files): Likewise.
-	* modules/posix_spawnp-tests (Files): Likewise.
-	* modules/readutmp-tests (Files): Likewise.
-	* modules/sh-quote-tests (Files): Likewise.
-	* modules/unigbrk/u16-grapheme-breaks-tests (Files): Likewise.
-	* modules/unigbrk/u16-grapheme-next-tests (Files): Likewise.
-	* modules/unigbrk/u16-grapheme-prev-tests (Files): Likewise.
-	* modules/unigbrk/u32-grapheme-breaks-tests (Files): Likewise.
-	* modules/unigbrk/u32-grapheme-next-tests (Files): Likewise.
-	* modules/unigbrk/u32-grapheme-prev-tests (Files): Likewise.
-	* modules/unigbrk/u8-grapheme-breaks-tests (Files): Likewise.
-	* modules/unigbrk/u8-grapheme-next-tests (Files): Likewise.
-	* modules/unigbrk/u8-grapheme-prev-tests (Files): Likewise.
-	* modules/unigbrk/uc-grapheme-breaks-tests (Files): Likewise.
-
-2023-08-13  Bruno Haible  <bruno@clisp.org>
-
-	nproc, physmem: Use sysctl() as a fallback on GNU/kFreeBSD.
-	* lib/nproc.c: Do include <sys/sysctl.h> on GNU/kFreeBSD.
-	(num_processors_ignoring_omp): Call sysctl on GNU/kFreeBSD.
-	* lib/physmem.c: Do include <sys/sysctl.h> on GNU/kFreeBSD.
-	(physmem_total, physmem_available): Call sysctl on GNU/kFreeBSD.
-
-2023-08-13  Bruno Haible  <bruno@clisp.org>
-
-	physmem: Add tests.
-	* tests/test-physmem.c: New file.
-	* modules/physmem-tests: New file.
-
-2023-08-13  Bruno Haible  <bruno@clisp.org>
-
-	readutmp, boot-time: Fix warning on glibc 2.30..2.31 on Linux.
-	Reported by Pádraig Brady in
-	<https://lists.gnu.org/archive/html/bug-gnulib/2023-08/msg00110.html>.
-	* lib/readutmp.c: Don't include <sys/sysctl.h> on glibc/Linux.
-	* lib/boot-time.c: Likewise.
-
-2023-08-13  Paul Eggert  <eggert@cs.ucla.edu>
-
-	fts: improve memory-allocation errno handling
-	* lib/fts.c (fts_read, fts_build): When enter_dir or setup_dir
-	fails, report its errno value back to the user.
-	(internal_function): Preserve errno.
-	* modules/fts (Depends-on): Add calloc-posix, free-posix,
-	malloc-posix, and realloc-posix, for better errno handling
-	on allocation failures.
-
-	hash: set errno on failure
-	* lib/hash.c: Include errno.h.
-	(compute_bucket_size, hash_initialize, hash_rehash)
-	(hash_insert_if_absent): Set errno reliably on failure.
-	(hash_free): Preserve errno, like plain 'free'.
-	* modules/hash (Depends-on): Depend on calloc-posix,
-	free-posix, malloc-posix, so that errno is set reliably.
-
-2023-08-13  Bruno Haible  <bruno@clisp.org>
-
-	readutmp, boot-time: Fix compilation error on old Android.
-	Reported by Po Lu in
-	<https://lists.gnu.org/archive/html/bug-gnulib/2023-08/msg00108.html>.
-	* lib/readutmp.h (BOOT_TIME): Add fallback.
-
-2023-08-13  Bruno Haible  <bruno@clisp.org>
-
-	readutmp, boot-time: Fix compilation error on Android API 8.
-	Reported by Po Lu in
-	<https://lists.gnu.org/archive/html/bug-gnulib/2023-08/msg00108.html>.
-	* m4/readutmp.m4 (gl_PREREQ_READUTMP_H): Test whether sysinfo is
-	declared.
-	* lib/boot-time-aux.h (get_linux_uptime): Invoke sysinfo only if it is
-	declared.
-	* doc/glibc-functions/sysinfo.texi: Mention the Android problem.
-
-2023-08-13  Bruno Haible  <bruno@clisp.org>
-
-	readutmp, boot-time: Fix compilation error on old Android.
-	Reported by Po Lu in
-	<https://lists.gnu.org/archive/html/bug-gnulib/2023-08/msg00108.html>.
-	* lib/readutmp.c (endutent): New fallback declaration, for Android.
-	(getutent): Remove Ultrix workaround from 2000-04-05.
-	* lib/boot-time.c: Likewise.
-	* m4/readutmp.m4 (gl_PREREQ_READUTMP_H): Test whether endutent is
-	declared, not getutent.
-	* doc/glibc-functions/endutent.texi: Mention the Android bug.
-
 2023-08-12  Paul Eggert  <eggert@cs.ucla.edu>
 
 	boot-time,readutmp: do not depend on c-strtod
diff --git a/doc/glibc-functions/endutent.texi b/doc/glibc-functions/endutent.texi
index b4f3dd397a..5e12e23c44 100644
--- a/doc/glibc-functions/endutent.texi
+++ b/doc/glibc-functions/endutent.texi
@@ -28,7 +28,4 @@ Portability problems not fixed by Gnulib:
 @item
 This function is missing on some platforms:
 macOS 11.1, FreeBSD 13.0, OpenBSD 6.7, Minix 3.1.8, mingw, MSVC 14.
-@item
-This function is not declared on some platforms:
-Android before ca.@: 2015.
 @end itemize
diff --git a/doc/glibc-functions/sysinfo.texi b/doc/glibc-functions/sysinfo.texi
index 16e12b12ac..3b1ade31a6 100644
--- a/doc/glibc-functions/sysinfo.texi
+++ b/doc/glibc-functions/sysinfo.texi
@@ -17,7 +17,4 @@ Portability problems not fixed by Gnulib:
 @item
 This function is missing on some platforms:
 macOS 11.1, FreeBSD 13.0, NetBSD 9.0, OpenBSD 6.7, Minix 3.1.8, AIX 5.1, Cygwin 1.7.9, mingw, MSVC 14.
-@item
-This function is not declared and thus not part of the Android API
-for Android API levels < 9.
 @end itemize
diff --git a/lib/boot-time-aux.h b/lib/boot-time-aux.h
index e59a0fd03c..348611fc85 100644
--- a/lib/boot-time-aux.h
+++ b/lib/boot-time-aux.h
@@ -65,7 +65,6 @@ get_linux_uptime (struct timespec *p_uptime)
     }
 # endif
 
-# if HAVE_DECL_SYSINFO /* not available in Android API < 9 */
   /* The sysinfo call returns the uptime with a resolution of 1 sec only.  */
   struct sysinfo info;
   if (sysinfo (&info) >= 0)
@@ -74,7 +73,6 @@ get_linux_uptime (struct timespec *p_uptime)
       p_uptime->tv_nsec = 0;
       return 0;
     }
-# endif
 
   return -1;
 }
diff --git a/lib/boot-time.c b/lib/boot-time.c
index fe5b5b88c8..d813bfa582 100644
--- a/lib/boot-time.c
+++ b/lib/boot-time.c
@@ -32,7 +32,7 @@
 # include <time.h>
 #endif
 
-#if HAVE_SYS_SYSCTL_H && !(defined __GLIBC__ && defined __linux__) && !defined __minix
+#if HAVE_SYS_SYSCTL_H && !defined __minix
 # if HAVE_SYS_PARAM_H
 #  include <sys/param.h>
 # endif
@@ -65,10 +65,8 @@
 # define UT_USER(UT) ((UT)->ut_user)
 #endif
 
-#if !HAVE_UTMPX_H && HAVE_UTMP_H && defined UTMP_NAME_FUNCTION
-# if !HAVE_DECL_ENDUTENT /* Android */
-void endutent (void);
-# endif
+#if !HAVE_UTMPX_H && HAVE_UTMP_H && defined UTMP_NAME_FUNCTION && !HAVE_DECL_GETUTENT
+struct utmp *getutent (void);
 #endif
 
 #if defined __linux__ || HAVE_UTMPX_H || HAVE_UTMP_H || defined __CYGWIN__ || defined _WIN32
diff --git a/lib/c-file-type.c b/lib/c-file-type.c
index efc17c5ccc..0fd9b92b9e 100644
--- a/lib/c-file-type.c
+++ b/lib/c-file-type.c
@@ -39,12 +39,12 @@ c_file_type (struct stat const *st)
   if (S_ISREG (st->st_mode))
     return st->st_size == 0 ? N_("regular empty file") : N_("regular file");
 
+  if (S_ISLNK (st->st_mode)) //must go before directory for windows directories that are symlinks
+    return N_("symbolic link");
+
   if (S_ISDIR (st->st_mode))
     return N_("directory");
 
-  if (S_ISLNK (st->st_mode))
-    return N_("symbolic link");
-
   /* Do the S_TYPEIS* macros next, as they may be implemented in terms
      of S_ISNAM, and we want the more-specialized interpretation.  */
 
diff --git a/lib/dirent.in.h b/lib/dirent.in.h
index d409a031ec..f9956d6edc 100644
--- a/lib/dirent.in.h
+++ b/lib/dirent.in.h
@@ -57,6 +57,7 @@ struct dirent
 #  define DT_SOCK   12          /* socket */
 #  define DT_WHT    14          /* whiteout */
 #  define GNULIB_defined_struct_dirent 1
+#  define HAVE_STRUCT_DIRENT_D_TYPE 1 //we could mod scripts that only look for rthiss or just say we have dirent
 # endif
 #endif
 
diff --git a/lib/filemode.c b/lib/filemode.c
index 318d287f27..c92bec74a4 100644
--- a/lib/filemode.c
+++ b/lib/filemode.c
@@ -45,6 +45,8 @@ ftypelet (mode_t bits)
   /* These are the most common, so test for them first.  */
   if (S_ISREG (bits))
     return '-';
+  if (S_ISLNK (bits)) //must go before dir as windows has symlink dirs
+    return 'l';
   if (S_ISDIR (bits))
     return 'd';
 
@@ -53,8 +55,6 @@ ftypelet (mode_t bits)
     return 'b';
   if (S_ISCHR (bits))
     return 'c';
-  if (S_ISLNK (bits))
-    return 'l';
   if (S_ISFIFO (bits))
     return 'p';
 
diff --git a/lib/fstatat.c b/lib/fstatat.c
index 372965ef5f..84f2e92044 100644
--- a/lib/fstatat.c
+++ b/lib/fstatat.c
@@ -113,7 +113,7 @@ rpl_fstatat (int fd, char const *file, struct stat *st, int flag)
 static int
 stat_func (char const *name, struct stat *st)
 {
-  return stat (name, st);
+  return lstat (name, st);
 }
 
 /* Likewise, if there is no native 'lstat', then the gnulib
diff --git a/lib/fts.c b/lib/fts.c
index faeb4b20a5..3646ec3e88 100644
--- a/lib/fts.c
+++ b/lib/fts.c
@@ -117,9 +117,7 @@ static char sccsid[] = "@(#)fts.c       8.6 (Berkeley) 8/14/94";
 #ifndef S_IFBLK
 # define S_IFBLK 0
 #endif
-#ifndef S_IFLNK
-# define S_IFLNK 0
-#endif
+
 #ifndef S_IFSOCK
 # define S_IFSOCK 0
 #endif
@@ -981,6 +979,7 @@ next:   tmp = p;
                         fts_load(sp, p);
                         if (! setup_dir(sp)) {
                                 free_dir(sp);
+                                __set_errno (ENOMEM);
                                 return (NULL);
                         }
                         goto check_for_dir;
@@ -1027,7 +1026,10 @@ check_for_dir:
                       sp->fts_dev = p->fts_statp->st_dev;
                     Dprintf (("  entering: %s\n", p->fts_path));
                     if (! enter_dir (sp, p))
-                      return NULL;
+                      {
+                        __set_errno (ENOMEM);
+                        return NULL;
+                      }
                   }
                 return p;
         }
@@ -1344,9 +1346,8 @@ fts_build (register FTS *sp, int type)
                   cur->fts_info = FTS_D;
                 else if (! enter_dir (sp, cur))
                   {
-                    int err = errno;
                     closedir_and_clear (cur->fts_dirp);
-                    __set_errno (err);
+                    __set_errno (ENOMEM);
                     return NULL;
                   }
               }
@@ -1820,6 +1821,8 @@ fts_stat(FTS *sp, register FTSENT *p, bool follow)
             return FTS_NS;
           }
 
+		if (S_ISLNK(sbp->st_mode))//must be before S_ISDIR due to windows having specific directory sym links
+			return (FTS_SL);
         if (S_ISDIR(sbp->st_mode)) {
                 if (ISDOT(p->fts_name)) {
                         /* Command-line "." and ".." are real directories. */
@@ -1828,8 +1831,7 @@ fts_stat(FTS *sp, register FTSENT *p, bool follow)
 
                 return (FTS_D);
         }
-        if (S_ISLNK(sbp->st_mode))
-                return (FTS_SL);
+
         if (S_ISREG(sbp->st_mode))
                 return (FTS_F);
         return (FTS_DEFAULT);
@@ -1934,7 +1936,6 @@ internal_function
 fts_lfree (register FTSENT *head)
 {
         register FTSENT *p;
-        int err = errno;
 
         /* Free a linked list of structures. */
         while ((p = head)) {
@@ -1943,8 +1944,6 @@ fts_lfree (register FTSENT *head)
                         closedir (p->fts_dirp);
                 free(p);
         }
-
-        __set_errno (err);
 }
 
 /*
diff --git a/lib/hash.c b/lib/hash.c
index a004885e28..918aa0d1c3 100644
--- a/lib/hash.c
+++ b/lib/hash.c
@@ -29,7 +29,6 @@
 #include "bitrotate.h"
 #include "xalloc-oversized.h"
 
-#include <errno.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -500,17 +499,13 @@ compute_bucket_size (size_t candidate, const Hash_tuning *tuning)
     {
       float new_candidate = candidate / tuning->growth_threshold;
       if ((float) SIZE_MAX <= new_candidate)
-        goto nomem;
+        return 0;
       candidate = new_candidate;
     }
   candidate = next_prime (candidate);
   if (xalloc_oversized (candidate, sizeof (struct hash_entry *)))
-    goto nomem;
+    return 0;
   return candidate;
-
- nomem:
-  errno = ENOMEM;
-  return 0;
 }
 
 Hash_table *
@@ -539,7 +534,6 @@ hash_initialize (size_t candidate, const Hash_tuning *tuning,
          if the user provides invalid tuning options, we silently revert to
          using the defaults, and ignore further request to change the tuning
          options.  */
-      errno = EINVAL;
       goto fail;
     }
 
@@ -613,7 +607,6 @@ hash_free (Hash_table *table)
   struct hash_entry *bucket;
   struct hash_entry *cursor;
   struct hash_entry *next;
-  int err = errno;
 
   /* Call the user data_freer function.  */
   if (table->data_freer && table->n_entries)
@@ -656,8 +649,6 @@ hash_free (Hash_table *table)
   /* Free the remainder of the hash table structure.  */
   free (table->bucket);
   free (table);
-
-  errno = err;
 }
 
 /* Insertion and deletion.  */
@@ -771,8 +762,8 @@ hash_find_entry (Hash_table *table, const void *entry,
 /* Internal helper, to move entries from SRC to DST.  Both tables must
    share the same free entry list.  If SAFE, only move overflow
    entries, saving bucket heads for later, so that no allocations will
-   occur.  Return false (setting errno) if the free entry list is
-   exhausted and an allocation fails.  */
+   occur.  Return false if the free entry list is exhausted and an
+   allocation fails.  */
 
 static bool
 transfer_entries (Hash_table *dst, Hash_table *src, bool safe)
@@ -919,14 +910,12 @@ hash_rehash (Hash_table *table, size_t candidate)
      passes.  Two passes give worse cache performance and takes
      longer, but at this point, we're already out of memory, so slow
      and safe is better than failure.  */
-  int err = errno;
   table->free_entry_list = new_table->free_entry_list;
   if (! (transfer_entries (table, new_table, true)
          && transfer_entries (table, new_table, false)))
     abort ();
   /* table->n_entries already holds its value.  */
   free (new_table->bucket);
-  errno = err;
   return false;
 }
 
@@ -973,10 +962,7 @@ hash_insert_if_absent (Hash_table *table, void const *entry,
                 * tuning->growth_threshold));
 
           if ((float) SIZE_MAX <= candidate)
-            {
-              errno = ENOMEM;
-              return -1;
-            }
+            return -1;
 
           /* If the rehash fails, arrange to return NULL.  */
           if (!hash_rehash (table, candidate))
diff --git a/lib/hash.h b/lib/hash.h
index af07242ff4..54d3f22f69 100644
--- a/lib/hash.h
+++ b/lib/hash.h
@@ -148,7 +148,7 @@ typedef void (*Hash_data_freer) (void *entry);
 /* Reclaim all storage associated with a hash table.  If a data_freer
    function has been supplied by the user when the hash table was created,
    this function applies it to the data of each entry before freeing that
-   entry.  This function preserves errno, like 'free'.  */
+   entry.  */
 extern void hash_free (Hash_table *table);
 
 /* Allocate and return a new hash table, or NULL upon failure.  The initial
@@ -183,9 +183,7 @@ extern void hash_free (Hash_table *table);
    You should specify this function only if you want these functions to free
    all of your 'data' data.  This is typically the case when your data is
    simply an auxiliary struct that you have malloc'd to aggregate several
-   values.
-
-   Set errno on failure; otherwise errno is unspecified.  */
+   values.  */
 _GL_ATTRIBUTE_NODISCARD
 extern Hash_table *hash_initialize (size_t candidate,
                                     const Hash_tuning *tuning,
@@ -194,7 +192,7 @@ extern Hash_table *hash_initialize (size_t candidate,
                                     Hash_data_freer data_freer)
   _GL_ATTRIBUTE_MALLOC _GL_ATTRIBUTE_DEALLOC (hash_free, 1);
 
-/* Like hash_initialize, but invokes xalloc_die instead of returning NULL.  */
+/* Same as hash_initialize, but invokes xalloc_die on memory exhaustion.  */
 /* This function is defined by module 'xhash'.  */
 _GL_ATTRIBUTE_NODISCARD
 extern Hash_table *hash_xinitialize (size_t candidate,
@@ -220,26 +218,25 @@ extern void hash_clear (Hash_table *table);
    the table may receive at least CANDIDATE different user entries, including
    those already in the table, before any other growth of the hash table size
    occurs.  If TUNING->IS_N_BUCKETS is true, then CANDIDATE specifies the
-   exact number of buckets desired.  Return true iff the rehash succeeded,
-   false (setting errno) otherwise.  */
+   exact number of buckets desired.  Return true iff the rehash succeeded.  */
 _GL_ATTRIBUTE_NODISCARD
 extern bool hash_rehash (Hash_table *table, size_t candidate);
 
 /* If ENTRY matches an entry already in the hash table, return the pointer
    to the entry from the table.  Otherwise, insert ENTRY and return ENTRY.
-   Return NULL (setting errno) if the storage required for insertion
-   cannot be allocated.  This implementation does not support
-   duplicate entries or insertion of NULL.  */
+   Return NULL if the storage required for insertion cannot be allocated.
+   This implementation does not support duplicate entries or insertion of
+   NULL.  */
 _GL_ATTRIBUTE_NODISCARD
 extern void *hash_insert (Hash_table *table, const void *entry);
 
-/* Same as hash_insert, but invokes xalloc_die instead of returning NULL.  */
+/* Same as hash_insert, but invokes xalloc_die on memory exhaustion.  */
 /* This function is defined by module 'xhash'.  */
 extern void *hash_xinsert (Hash_table *table, const void *entry);
 
 /* Insert ENTRY into hash TABLE if there is not already a matching entry.
 
-   Return -1 (setting errno) upon memory allocation failure.
+   Return -1 upon memory allocation failure.
    Return 1 if insertion succeeded.
    Return 0 if there is already a matching entry in the table,
    and in that case, if MATCHED_ENT is non-NULL, set *MATCHED_ENT
diff --git a/lib/nproc.c b/lib/nproc.c
index e3de1873a9..2740c458c1 100644
--- a/lib/nproc.c
+++ b/lib/nproc.c
@@ -46,7 +46,7 @@
 # include <sys/param.h>
 #endif
 
-#if HAVE_SYS_SYSCTL_H && !(defined __GLIBC__ && defined __linux__)
+#if HAVE_SYS_SYSCTL_H && ! defined __GLIBC__
 # include <sys/sysctl.h>
 #endif
 
@@ -306,7 +306,7 @@ num_processors_ignoring_omp (enum nproc_query query)
   /* Finally, as fallback, use the APIs that don't distinguish between
      NPROC_CURRENT and NPROC_ALL.  */
 
-#if HAVE_SYSCTL && !(defined __GLIBC__ && defined __linux__) && defined HW_NCPU
+#if HAVE_SYSCTL && ! defined __GLIBC__ && defined HW_NCPU
   { /* This works on macOS, FreeBSD, NetBSD, OpenBSD.
        macOS 10.14 does not allow mib to be const.  */
     int nprocs;
diff --git a/lib/physmem.c b/lib/physmem.c
index 398f99b727..f450587141 100644
--- a/lib/physmem.c
+++ b/lib/physmem.c
@@ -50,7 +50,7 @@
 # include <sys/param.h>
 #endif
 
-#if HAVE_SYS_SYSCTL_H && !(defined __GLIBC__ && defined __linux__)
+#if HAVE_SYS_SYSCTL_H && ! defined __GLIBC__
 # include <sys/sysctl.h>
 #endif
 
@@ -96,7 +96,7 @@ double
 physmem_total (void)
 {
 #if defined _SC_PHYS_PAGES && defined _SC_PAGESIZE
-  { /* This works on linux-gnu, kfreebsd-gnu, solaris2, and cygwin.  */
+  { /* This works on linux-gnu, solaris2 and cygwin.  */
     double pages = sysconf (_SC_PHYS_PAGES);
     double pagesize = sysconf (_SC_PAGESIZE);
     if (0 <= pages && 0 <= pagesize)
@@ -153,8 +153,8 @@ physmem_total (void)
   }
 #endif
 
-#if HAVE_SYSCTL && !(defined __GLIBC__ && defined __linux__) && defined HW_PHYSMEM
-  { /* This works on *bsd, kfreebsd-gnu, and darwin.  */
+#if HAVE_SYSCTL && ! defined __GLIBC__ && defined HW_PHYSMEM
+  { /* This works on *bsd and darwin.  */
     unsigned int physmem;
     size_t len = sizeof physmem;
     static int mib[2] = { CTL_HW, HW_PHYSMEM };
@@ -208,7 +208,7 @@ double
 physmem_available (void)
 {
 #if defined _SC_AVPHYS_PAGES && defined _SC_PAGESIZE
-  { /* This works on linux-gnu, kfreebsd-gnu, solaris2, and cygwin.  */
+  { /* This works on linux-gnu, solaris2 and cygwin.  */
     double pages = sysconf (_SC_AVPHYS_PAGES);
     double pagesize = sysconf (_SC_PAGESIZE);
     if (0 <= pages && 0 <= pagesize)
@@ -267,8 +267,8 @@ physmem_available (void)
   }
 #endif
 
-#if HAVE_SYSCTL && !(defined __GLIBC__ && defined __linux__) && defined HW_USERMEM
-  { /* This works on *bsd, kfreebsd-gnu, and darwin.  */
+#if HAVE_SYSCTL && ! defined __GLIBC__ && defined HW_USERMEM
+  { /* This works on *bsd and darwin.  */
     unsigned int usermem;
     size_t len = sizeof usermem;
     static int mib[2] = { CTL_HW, HW_USERMEM };
diff --git a/lib/readdir.c b/lib/readdir.c
index 04dbba21bc..608f1f3fe5 100644
--- a/lib/readdir.c
+++ b/lib/readdir.c
@@ -77,10 +77,11 @@ readdir (DIR *dirp)
 
   dirp->status = 0;
 
-  if (dirp->entry.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
-    type = DT_DIR;
-  else if (dirp->entry.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)
+
+  if (dirp->entry.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) //linux shows sym l inked directories as symlinks not as directories
     type = DT_LNK;
+  else if (dirp->entry.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
+	  type = DT_DIR;
   else if ((dirp->entry.dwFileAttributes
             & ~(FILE_ATTRIBUTE_READONLY
                 | FILE_ATTRIBUTE_HIDDEN
diff --git a/lib/readlink.c b/lib/readlink.c
index 14bbb7f10c..23549b8989 100644
--- a/lib/readlink.c
+++ b/lib/readlink.c
@@ -27,7 +27,7 @@
 
 /* readlink() substitute for systems that don't have a readlink() function,
    such as DJGPP 2.03 and mingw32.  */
-
+#ifndef _WIN32
 ssize_t
 readlink (char const *file, _GL_UNUSED char *buf,
           _GL_UNUSED size_t bufsize)
@@ -37,10 +37,175 @@ readlink (char const *file, _GL_UNUSED char *buf,
   /* In general we should use lstat() here, not stat().  But on platforms
      without symbolic links, lstat() - if it exists - would be equivalent to
      stat(), therefore we can use stat().  This saves us a configure check.  */
-  if (stat (file, &statbuf) >= 0)
+  if (lstat (file, &statbuf) >= 0)
     errno = EINVAL;
   return -1;
 }
+#else
+#define WIN32_LEAN_AND_MEAN
+#include <Windows.h>
+#include <ioapiset.h>
+#include <winioctl.h>
+#define __extension__
+#define _ANONYMOUS_UNION	__extension__
+typedef struct _REPARSE_DATA_BUFFER {
+	ULONG ReparseTag;
+	USHORT ReparseDataLength;
+	USHORT Reserved;
+	_ANONYMOUS_UNION union {
+		struct {
+			USHORT SubstituteNameOffset;
+			USHORT SubstituteNameLength;
+			USHORT PrintNameOffset;
+			USHORT PrintNameLength;
+			ULONG Flags;
+			WCHAR PathBuffer[1];
+		} SymbolicLinkReparseBuffer;
+		struct {
+			USHORT SubstituteNameOffset;
+			USHORT SubstituteNameLength;
+			USHORT PrintNameOffset;
+			USHORT PrintNameLength;
+			WCHAR PathBuffer[1];
+		} MountPointReparseBuffer;
+		struct {
+			UCHAR DataBuffer[1];
+		} GenericReparseBuffer;
+	} DUMMYUNIONNAME;
+} REPARSE_DATA_BUFFER, * PREPARSE_DATA_BUFFER;
+
+#define REPARSE_DATA_BUFFER_HEADER_SIZE   FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer)
+// https://github.com/joyent/libuv/blob/1dc2709b999a84520ab1b3c56c0e082bf8617c1f/src/win/fs.c#L971
+ssize_t readlink(char const* file, char* target,
+	size_t target_len) {
+	HANDLE handle = CreateFileA(file, 0, 0, NULL, OPEN_EXISTING, FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS, NULL);//need FILE_FLAG_BACKUP_SEMANTICS  to be able to open directory ssymlinks
+	if (handle == INVALID_HANDLE_VALUE)
+		return -1;
+
+	char buffer[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];
+	REPARSE_DATA_BUFFER* reparse_data = (REPARSE_DATA_BUFFER*)buffer;
+	WCHAR* w_target;
+	DWORD w_target_len;
+	DWORD bytes;
+
+	if (!DeviceIoControl(handle,
+		FSCTL_GET_REPARSE_POINT,
+		NULL,
+		0,
+		buffer,
+		sizeof buffer,
+		&bytes,
+		NULL)) {
+		errno = GetLastError();
+		if (errno == ERROR_NOT_A_REPARSE_POINT)
+			errno = EINVAL;//for linux readlink should set EINVAL if not a symbolic link
+		CloseHandle(handle);
+		return -1;
+	}
+
+	if (reparse_data->ReparseTag == IO_REPARSE_TAG_SYMLINK) {
+		/* Real symlink */
+		w_target = reparse_data->SymbolicLinkReparseBuffer.PathBuffer +
+			(reparse_data->SymbolicLinkReparseBuffer.SubstituteNameOffset /
+				sizeof(WCHAR));
+		w_target_len =
+			reparse_data->SymbolicLinkReparseBuffer.SubstituteNameLength /
+			sizeof(WCHAR);
+
+		/* Real symlinks can contain pretty much everything, but the only thing */
+		/* we really care about is undoing the implicit conversion to an NT */
+		/* namespaced path that CreateSymbolicLink will perform on absolute */
+		/* paths. If the path is win32-namespaced then the user must have */
+		/* explicitly made it so, and we better just return the unmodified */
+		/* reparse data. */
+		if (w_target_len >= 4 &&
+			w_target[0] == L'\\' &&
+			w_target[1] == L'?' &&
+			w_target[2] == L'?' &&
+			w_target[3] == L'\\') {
+			/* Starts with \??\ */
+			if (w_target_len >= 6 &&
+				((w_target[4] >= L'A' && w_target[4] <= L'Z') ||
+					(w_target[4] >= L'a' && w_target[4] <= L'z')) &&
+				w_target[5] == L':' &&
+				(w_target_len == 6 || w_target[6] == L'\\')) {
+				/* \??\«drive»:\ */
+				w_target += 4;
+				w_target_len -= 4;
+
+			}
+			else if (w_target_len >= 8 &&
+				(w_target[4] == L'U' || w_target[4] == L'u') &&
+				(w_target[5] == L'N' || w_target[5] == L'n') &&
+				(w_target[6] == L'C' || w_target[6] == L'c') &&
+				w_target[7] == L'\\') {
+				/* \??\UNC\«server»\«share»\ - make sure the final path looks like */
+				/* \\«server»\«share»\ */
+				w_target += 6;
+				w_target[0] = L'\\';
+				w_target_len -= 6;
+			}
+		}
+
+	}
+	else if (reparse_data->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT) {
+		/* Junction. */
+		w_target = reparse_data->MountPointReparseBuffer.PathBuffer +
+			(reparse_data->MountPointReparseBuffer.SubstituteNameOffset /
+				sizeof(WCHAR));
+		w_target_len = reparse_data->MountPointReparseBuffer.SubstituteNameLength /
+			sizeof(WCHAR);
+
+		/* Only treat junctions that look like \??\«drive»:\ as symlink. */
+		/* Junctions can also be used as mount points, like \??\Volume{«guid»}, */
+		/* but that's confusing for programs since they wouldn't be able to */
+		/* actually understand such a path when returned by uv_readlink(). */
+		/* UNC paths are never valid for junctions so we don't care about them. */
+		if (!(w_target_len >= 6 &&
+			w_target[0] == L'\\' &&
+			w_target[1] == L'?' &&
+			w_target[2] == L'?' &&
+			w_target[3] == L'\\' &&
+			((w_target[4] >= L'A' && w_target[4] <= L'Z') ||
+				(w_target[4] >= L'a' && w_target[4] <= L'z')) &&
+			w_target[5] == L':' &&
+			(w_target_len == 6 || w_target[6] == L'\\'))) {
+			SetLastError(ERROR_SYMLINK_NOT_SUPPORTED);
+			CloseHandle(handle);
+			return -1;
+		}
+
+		/* Remove leading \??\ */
+		w_target += 4;
+		w_target_len -= 4;
+
+	}
+	else {
+		/* Reparse tag does not indicate a symlink. */
+		SetLastError(ERROR_SYMLINK_NOT_SUPPORTED);
+		CloseHandle(handle);
+		return -1;
+	}
+
+
+	int rd= WideCharToMultiByte(CP_UTF8,
+		0,
+		w_target,
+		w_target_len,
+		target,
+		target_len,
+		NULL,
+		NULL);
+	target[rd] = '\0';
+	CloseHandle(handle);
+	return rd;
+
+
+}
+
+#endif
+
+
 
 #else /* HAVE_READLINK */
 
diff --git a/lib/readutmp.c b/lib/readutmp.c
index 7967db60a8..ef9f0aff43 100644
--- a/lib/readutmp.c
+++ b/lib/readutmp.c
@@ -40,7 +40,7 @@
 # include <systemd/sd-login.h>
 #endif
 
-#if HAVE_SYS_SYSCTL_H && !(defined __GLIBC__ && defined __linux__) && !defined __minix
+#if HAVE_SYS_SYSCTL_H && !defined __minix
 # if HAVE_SYS_PARAM_H
 #  include <sys/param.h>
 # endif
@@ -314,11 +314,9 @@ have_boot_time (struct utmp_alloc a)
   return false;
 }
 
-#if !HAVE_UTMPX_H && HAVE_UTMP_H && defined UTMP_NAME_FUNCTION
-# if !HAVE_DECL_ENDUTENT /* Android */
-void endutent (void);
+# if !HAVE_UTMPX_H && HAVE_UTMP_H && defined UTMP_NAME_FUNCTION && !HAVE_DECL_GETUTENT
+struct utmp *getutent (void);
 # endif
-#endif
 
 static int
 read_utmp_from_file (char const *file, idx_t *n_entries, STRUCT_UTMP **utmp_buf,
diff --git a/lib/readutmp.h b/lib/readutmp.h
index 3ddecf3727..1cf588d265 100644
--- a/lib/readutmp.h
+++ b/lib/readutmp.h
@@ -136,18 +136,14 @@ enum { UT_HOST_SIZE = -1 };
 /* This is a near-copy of glibc's struct utmpx, which stops working
    after the year 2038.  Unlike the glibc version, struct utmpx32
    describes the file format even if time_t is 64 bits.  */
-#define _GL_UT_USER_SIZE  sizeof (((struct utmpx *) 0)->ut_user)
-#define _GL_UT_ID_SIZE    sizeof (((struct utmpx *) 0)->ut_id)
-#define _GL_UT_LINE_SIZE  sizeof (((struct utmpx *) 0)->ut_line)
-#define _GL_UT_HOST_SIZE  sizeof (((struct utmpx *) 0)->ut_host)
 struct utmpx32
 {
   short int ut_type;               /* Type of login.  */
   pid_t ut_pid;                    /* Process ID of login process.  */
-  char ut_line[_GL_UT_LINE_SIZE];  /* Devicename.  */
-  char ut_id[_GL_UT_ID_SIZE];      /* Inittab ID.  */
-  char ut_user[_GL_UT_USER_SIZE];  /* Username.  */
-  char ut_host[_GL_UT_HOST_SIZE];  /* Hostname for remote login. */
+  char ut_line[__UT_LINESIZE];     /* Devicename.  */
+  char ut_id[4];                   /* Inittab ID.  */
+  char ut_user[__UT_USERSIZE];     /* Username.  */
+  char ut_host[__UT_HOSTSIZE];     /* Hostname for remote login. */
   struct __exit_status ut_exit;    /* Exit status of a process marked
                                       as DEAD_PROCESS.  */
   /* The fields ut_session and ut_tv must be the same size when compiled
@@ -253,13 +249,6 @@ struct utmpx32
 # define WTMP_FILE "/etc/wtmp"
 #endif
 
-/* In early versions of Android, <utmp.h> did not define BOOT_TIME, only
-   USER_PROCESS.  We need to use the value that is defined in newer versions
-   of Android.  */
-#if defined __ANDROID__ && !defined BOOT_TIME
-# define BOOT_TIME 2
-#endif
-
 /* Some platforms, such as OpenBSD, don't have an ut_type field and don't have
    the BOOT_TIME and USER_PROCESS macros.  But we want to support them in
    'struct gl_utmp'.  */
diff --git a/lib/stat-w32.c b/lib/stat-w32.c
index 2f01197584..28f8f74ea4 100644
--- a/lib/stat-w32.c
+++ b/lib/stat-w32.c
@@ -260,13 +260,18 @@ _gl_fstat_by_handle (HANDLE h, const char *path, struct stat *buf)
       buf->st_ino = 0;
 #endif
 
+	  int is_sym_link = info.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT;
       /* st_mode.  */
       unsigned int mode =
         /* XXX How to handle FILE_ATTRIBUTE_REPARSE_POINT ?  */
-        ((info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? _S_IFDIR | S_IEXEC_UGO : _S_IFREG)
+        ((info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? _S_IFDIR | S_IEXEC_UGO : 0)
         | S_IREAD_UGO
+		| (is_sym_link ? S_IFLNK : 0)
         | ((info.dwFileAttributes & FILE_ATTRIBUTE_READONLY) ? 0 : S_IWRITE_UGO);
-      if (!(info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
+	  if (!(info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY || is_sym_link))
+		  mode |= _S_IFREG;
+
+      if (!(info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY && !is_sym_link))
         {
           /* Determine whether the file is executable by looking at the file
              name suffix.
diff --git a/lib/stat.c b/lib/stat.c
index 7987e26583..d258d141d2 100644
--- a/lib/stat.c
+++ b/lib/stat.c
@@ -107,7 +107,24 @@ is_unc_root (const char *rname)
    correctly.  */
 
 int
-rpl_stat (char const *name, struct stat *buf)
+rpl_stat(char const* name, struct stat* buf)
+{
+	return _rpl_stat(name, buf, 0);
+
+}
+
+#undef lstat
+int
+lstat(char const* name, struct stat* buf)
+{
+	int do_lstat = 1;
+	if (*name && ISSLASH(name[strlen(name) - 1]))//if it ends in a slash always resolve as a directory not the symlink by forrcing normal stat mode
+		do_lstat = 0;
+	return _rpl_stat(name, buf, do_lstat);
+
+}
+int
+_rpl_stat (char const *name, struct stat *buf, int do_lstat)
 {
 #ifdef WINDOWS_NATIVE
   /* Fill the fields ourselves, because the original stat function returns
@@ -201,6 +218,11 @@ rpl_stat (char const *name, struct stat *buf)
          CreateFile
          <https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-createfilea>
          <https://docs.microsoft.com/en-us/windows/desktop/FileIO/creating-and-opening-files>  */
+		DWORD flags = FILE_FLAG_BACKUP_SEMANTICS;
+
+	  if (do_lstat)
+		flags |= FILE_FLAG_OPEN_REPARSE_POINT;
+
       HANDLE h =
         CreateFile (rname,
                     FILE_READ_ATTRIBUTES,
@@ -210,11 +232,13 @@ rpl_stat (char const *name, struct stat *buf)
                     /* FILE_FLAG_POSIX_SEMANTICS (treat file names that differ only
                        in case as different) makes sense only when applied to *all*
                        filesystem operations.  */
-                    FILE_FLAG_BACKUP_SEMANTICS /* | FILE_FLAG_POSIX_SEMANTICS */,
+                    flags /* | FILE_FLAG_POSIX_SEMANTICS */,
                     NULL);
       if (h != INVALID_HANDLE_VALUE)
         {
           ret = _gl_fstat_by_handle (h, rname, buf);
+		  if (ret && do_lstat && GetLastError() == ERROR_SYMLINK_NOT_SUPPORTED)
+			  return _rpl_stat(name, buf, 0);
           CloseHandle (h);
           goto done;
         }
@@ -277,13 +301,17 @@ rpl_stat (char const *name, struct stat *buf)
       buf->st_ino = 0;
 # endif
 
+	  int is_sym_link = info.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT;
       /* st_mode.  */
       unsigned int mode =
         /* XXX How to handle FILE_ATTRIBUTE_REPARSE_POINT ?  */
-        ((info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? _S_IFDIR | S_IEXEC_UGO : _S_IFREG)
+		  ((info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? _S_IFDIR | S_IEXEC_UGO : 0)
         | S_IREAD_UGO
+		  | (is_sym_link ? S_IFLNK : 0)
         | ((info.dwFileAttributes & FILE_ATTRIBUTE_READONLY) ? 0 : S_IWRITE_UGO);
-      if (!(info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
+	  if (!(info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY || is_sym_link))
+		  mode |= _S_IFREG;
+	  if (!(info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY && !is_sym_link))
         {
           /* Determine whether the file is executable by looking at the file
              name suffix.  */
diff --git a/lib/symlink.c b/lib/symlink.c
index b5009ae835..abca0f5b50 100644
--- a/lib/symlink.c
+++ b/lib/symlink.c
@@ -24,7 +24,10 @@
 #include <sys/stat.h>
 
 
-#if HAVE_SYMLINK
+#if HAVE_SYMLINK || REPLACE_SYMLINK
+#ifdef _WIN32
+#include <Windows.h>
+#endif
 
 # undef symlink
 
@@ -40,7 +43,26 @@ rpl_symlink (char const *contents, char const *name)
         errno = EEXIST;
       return -1;
     }
-  return symlink (contents, name);
+#ifdef _WIN32
+  struct stat path_stat;
+  stat(contents, &path_stat);
+  DWORD flags = SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE;
+  if (path_stat.st_mode & _S_IFDIR)
+	  flags |= SYMBOLIC_LINK_FLAG_DIRECTORY;
+
+  if (CreateSymbolicLink(name, contents, flags))
+	  return 0;
+
+  errno = GetLastError();
+  if (errno == ERROR_ALREADY_EXISTS) //windows will return this if trying to link a folder and target is a folder name
+	  errno = EEXIST;
+  if (errno == ERROR_ACCESS_DENIED) //if passing an existing folder this will occur our fallback behavior expects EEXIST in that case
+	  errno = EEXIST;
+  return -1;
+#else
+  return symlink(contents, name);
+#endif
+
 }
 
 #else /* !HAVE_SYMLINK */
diff --git a/lib/symlinkat.c b/lib/symlinkat.c
index 11eda8289a..7bae7b1486 100644
--- a/lib/symlinkat.c
+++ b/lib/symlinkat.c
@@ -47,7 +47,7 @@ rpl_symlinkat (char const *contents, int fd, char const *name)
   return symlinkat (contents, fd, name);
 }
 
-#elif !HAVE_SYMLINK
+#elif !HAVE_SYMLINK && !REPLACE_SYMLINK
 /* Mingw lacks symlink, and it is more efficient to provide a trivial
    wrapper than to go through at-func.c to call rpl_symlink.  */
 
diff --git a/lib/sys_stat.in.h b/lib/sys_stat.in.h
index ad4da17fa4..523873e39f 100644
--- a/lib/sys_stat.in.h
+++ b/lib/sys_stat.in.h
@@ -220,12 +220,23 @@ struct stat
 # endif
 #endif
 
+#ifndef _WIN32
 #ifndef S_ISLNK
 # ifdef S_IFLNK
 #  define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
 # else
 #  define S_ISLNK(m) 0
 # endif
+#endif
+#else
+#define S_IFLNK  0x0800 // symbolic link / junciton point
+#undef S_IFMT
+#define S_IFMT (_S_IFMT | S_IFLNK)
+#define S_ISLNK(m) (((m) & (S_IFMT ^ S_IFDIR)) == S_IFLNK)
+#define S_ISHARDDIR(m) (((m) & S_IFMT) == S_IFDIR)
+#undef S_ISDIR
+#define S_ISDIR(m) (((m) & (S_IFMT ^ S_IFLNK)) == S_IFDIR)
+
 #endif
 
 #ifndef S_ISMPB /* V7 */
@@ -878,7 +889,11 @@ _GL_WARN_ON_USE (stat, "stat is unportable - "
 /* mingw does not support symlinks, therefore it does not have lstat.  But
    without links, stat does just fine.  */
 #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#ifndef _WIN32 //not sure this is used anywherre but windows so may be redundant
 #   define lstat stat
+#else
+int lstat(char const* name, struct stat* buf);
+#endif
 #  endif
 _GL_CXXALIAS_RPL_1 (lstat, stat, int,
                     (const char *restrict name, struct stat *restrict buf));
diff --git a/lib/unlink.c b/lib/unlink.c
index d77d26298e..6359e1c9fb 100644
--- a/lib/unlink.c
+++ b/lib/unlink.c
@@ -93,6 +93,22 @@ rpl_unlink (char const *name)
         }
 #endif
       result = unlink (name);
+#ifdef _WIN32
+    if (result && errno == EACCES) { //windows won't let us delete readonly files by default but things like RM have already verified we wanted to delete it
+      chmod(name, _S_IREAD | _S_IWRITE);
+      result = unlink(name);
+    }
+    if (result && errno == EACCES) { //fix unlinking of symlinked dirs in windows
+      struct stat st;
+      result = lstat(name, &st);
+      if (!result && S_ISLNK(st.st_mode) && S_ISDIR(st.st_mode))
+        result = _rmdir(name);
+      else {
+        result = -1;
+        errno = EACCES;//restore orig errno
+      }
+    }
+#endif
     }
   return result;
 }
diff --git a/lib/utime.c b/lib/utime.c
index 3cf1840feb..79e4ce3320 100644
--- a/lib/utime.c
+++ b/lib/utime.c
@@ -96,6 +96,7 @@ _gl_utimens_windows (const char *name, struct timespec ts[2])
                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                 NULL,
                 OPEN_EXISTING,
+                FILE_FLAG_OPEN_REPARSE_POINT | //If it is not a reparse point this is ignored, this allows us to modify the reparse point itself
                 /* FILE_FLAG_POSIX_SEMANTICS (treat file names that differ only
                    in case as different) makes sense only when applied to *all*
                    filesystem operations.  */
diff --git a/lib/utimens.c b/lib/utimens.c
index faa197e6cb..1a25964744 100644
--- a/lib/utimens.c
+++ b/lib/utimens.c
@@ -639,7 +639,9 @@ lutimens (char const *file, struct timespec const timespec[2])
   /* Out of luck for symlinks, but we still handle regular files.  */
   if (!(adjustment_needed || REPLACE_FUNC_STAT_FILE) && lstat (file, &st))
     return -1;
+#ifndef _WIN32
   if (!S_ISLNK (st.st_mode))
+#endif // !_WIN32
     return fdutimens (-1, file, ts);
   errno = ENOSYS;
   return -1;
diff --git a/m4/readutmp.m4 b/m4/readutmp.m4
index 0a47f4bb77..fff8d4eb7b 100644
--- a/m4/readutmp.m4
+++ b/m4/readutmp.m4
@@ -1,4 +1,4 @@
-# readutmp.m4 serial 30
+# readutmp.m4 serial 28
 dnl Copyright (C) 2002-2023 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
@@ -55,7 +55,7 @@ AC_DEFUN_ONCE([gl_PREREQ_READUTMP_H],
   if test $ac_cv_header_utmp_h = yes || test $ac_cv_header_utmpx_h = yes; then
     dnl Prerequisites of lib/readutmp.h and lib/readutmp.c.
     AC_CHECK_FUNCS_ONCE([utmpname utmpxname])
-    AC_CHECK_DECLS([endutent],,,[[
+    AC_CHECK_DECLS([getutent],,,[[
 /* <sys/types.h> is a prerequisite of <utmp.h> on FreeBSD 8.0, OpenBSD 4.6.  */
 #include <sys/types.h>
 #ifdef HAVE_UTMP_H
@@ -103,10 +103,6 @@ AC_INCLUDES_DEFAULT
     AC_CHECK_MEMBERS([struct utmp.ut_exit.e_termination],,,[$utmp_includes])
   fi
 
-  AC_CHECK_DECLS([sysinfo],,,[[
-    #include <sys/sysinfo.h>
-    ]])
-
   AC_CHECK_HEADERS_ONCE([sys/param.h])
   dnl <sys/sysctl.h> requires <sys/param.h> on OpenBSD 4.0.
   AC_CHECK_HEADERS([sys/sysctl.h],,,
diff --git a/m4/stdint.m4 b/m4/stdint.m4
index b9f764d4c1..d6961b0993 100644
--- a/m4/stdint.m4
+++ b/m4/stdint.m4
@@ -1,4 +1,4 @@
-# stdint.m4 serial 62
+# stdint.m4 serial 61
 dnl Copyright (C) 2001-2023 Free Software Foundation, Inc.
 dnl This file is free software; the Free Software Foundation
 dnl gives unlimited permission to copy and/or distribute it,
@@ -150,10 +150,7 @@ intmax_t i = INTMAX_MAX;
 uintmax_t j = UINTMAX_MAX;
 
 /* Check that SIZE_MAX has the correct type, if possible.  */
-/* ISO C 11 mandates _Generic, but GCC versions < 4.9 lack it.  */
-#if 201112 <= __STDC_VERSION__ \
-    && (!defined __GNUC__ || 4 < __GNUC__ + (9 <= __GNUC_MINOR__) \
-        || defined __clang__)
+#if 201112 <= __STDC_VERSION__
 int k = _Generic (SIZE_MAX, size_t: 0);
 #elif (2 <= __GNUC__ || 4 <= __clang_major__ || defined __IBM__TYPEOF__ \
        || (0x5110 <= __SUNPRO_C && !__STDC__))
diff --git a/m4/symlink.m4 b/m4/symlink.m4
index 52d6c115ca..2b235cd4b4 100644
--- a/m4/symlink.m4
+++ b/m4/symlink.m4
@@ -17,7 +17,17 @@ AC_DEFUN([gl_FUNC_SYMLINK],
   dnl that compilation can proceed with fewer ifdefs.  On FreeBSD 7.2, AIX 7.1,
   dnl and Solaris 9, we want to fix a bug with trailing slash handling.
   if test $ac_cv_func_symlink = no; then
-    HAVE_SYMLINK=0
+  case "$host_os" in
+
+  	  mingw*)
+  	  	REPLACE_SYMLINK=1
+  	  	HAVE_SYMLINK=0
+        AC_DEFINE([REPLACE_SYMLINK],[1], [Define to 1 if gnulib's symlink() replacement is used.])
+  	   ;;
+      *)
+        HAVE_SYMLINK=0
+        ;;
+	esac
   else
     AC_CACHE_CHECK([whether symlink handles trailing slash correctly],
       [gl_cv_func_symlink_works],
diff --git a/modules/boot-time-tests b/modules/boot-time-tests
index 9436f0e8b5..bb56ee36e5 100644
--- a/modules/boot-time-tests
+++ b/modules/boot-time-tests
@@ -1,6 +1,5 @@
 Files:
 tests/test-boot-time.c
-tests/macros.h
 
 Depends-on:
 
diff --git a/modules/dprintf-gnu-tests b/modules/dprintf-gnu-tests
index 176d64c10c..117e615649 100644
--- a/modules/dprintf-gnu-tests
+++ b/modules/dprintf-gnu-tests
@@ -2,7 +2,6 @@ Files:
 tests/test-dprintf-gnu.sh
 tests/test-dprintf-gnu.c
 tests/test-printf-gnu.output
-tests/macros.h
 
 Depends-on:
 dprintf-posix-tests
diff --git a/modules/fclose-tests b/modules/fclose-tests
index 6e8ebe8343..0f36e0d50e 100644
--- a/modules/fclose-tests
+++ b/modules/fclose-tests
@@ -1,6 +1,5 @@
 Files:
 tests/test-fclose.c
-tests/macros.h
 
 Depends-on:
 fdopen
diff --git a/modules/fts b/modules/fts
index b754e0f572..fe56bae6e0 100644
--- a/modules/fts
+++ b/modules/fts
@@ -11,7 +11,6 @@ Depends-on:
 alignasof
 attribute
 c99
-calloc-posix
 closedir
 cycle-check
 d-ino
@@ -20,19 +19,16 @@ fchdir
 fcntl
 fcntl-h
 flexmember
-free-posix
 fstat
 hash
 i-ring
 lstat
-malloc-posix
 memmove
 open
 openat-h
 opendir
 opendirat
 readdir
-realloc-posix
 stdbool
 stddef
 stdint
diff --git a/modules/getcwd-tests b/modules/getcwd-tests
index 4a8aee2540..c842c77115 100644
--- a/modules/getcwd-tests
+++ b/modules/getcwd-tests
@@ -2,7 +2,6 @@ Files:
 tests/test-getcwd.sh
 tests/test-getcwd.c
 tests/qemu.h
-tests/macros.h
 
 Depends-on:
 errno
diff --git a/modules/hash b/modules/hash
index e837317d9f..42502e749e 100644
--- a/modules/hash
+++ b/modules/hash
@@ -7,9 +7,6 @@ lib/hash.h
 
 Depends-on:
 bitrotate
-calloc-posix
-free-posix
-malloc-posix
 stdbool
 stdint
 xalloc-oversized
diff --git a/modules/lock-tests b/modules/lock-tests
index 502c36882f..31d627da2a 100644
--- a/modules/lock-tests
+++ b/modules/lock-tests
@@ -3,7 +3,6 @@ tests/test-rwlock1.c
 tests/test-lock.c
 tests/test-once.c
 tests/atomic-int-gnulib.h
-tests/macros.h
 m4/semaphore.m4
 
 Depends-on:
diff --git a/modules/nullptr-c++-tests b/modules/nullptr-c++-tests
index 391881974d..ae60f4b360 100644
--- a/modules/nullptr-c++-tests
+++ b/modules/nullptr-c++-tests
@@ -1,6 +1,5 @@
 Files:
 tests/test-nullptr-c++.cc
-tests/macros.h
 
 Status:
 c++-test
diff --git a/modules/physmem-tests b/modules/physmem-tests
deleted file mode 100644
index c37c41cd7e..0000000000
--- a/modules/physmem-tests
+++ /dev/null
@@ -1,11 +0,0 @@
-Files:
-tests/test-physmem.c
-tests/macros.h
-
-Depends-on:
-
-configure.ac:
-
-Makefile.am:
-TESTS += test-physmem
-check_PROGRAMS += test-physmem
diff --git a/modules/posix_spawn-tests b/modules/posix_spawn-tests
index ef56cf6023..7d316c96f6 100644
--- a/modules/posix_spawn-tests
+++ b/modules/posix_spawn-tests
@@ -8,7 +8,6 @@ tests/executable-script
 tests/executable-script.sh
 tests/executable-shell-script
 tests/signature.h
-tests/macros.h
 
 Depends-on:
 posix_spawn_file_actions_init
diff --git a/modules/posix_spawnp-tests b/modules/posix_spawnp-tests
index 16369ff52f..4ac569e318 100644
--- a/modules/posix_spawnp-tests
+++ b/modules/posix_spawnp-tests
@@ -8,7 +8,6 @@ tests/executable-script
 tests/executable-script.sh
 tests/executable-shell-script
 tests/signature.h
-tests/macros.h
 
 Depends-on:
 posix_spawn_file_actions_init
diff --git a/modules/readutmp-tests b/modules/readutmp-tests
index c21fe9c4be..5543b30fac 100644
--- a/modules/readutmp-tests
+++ b/modules/readutmp-tests
@@ -1,6 +1,5 @@
 Files:
 tests/test-readutmp.c
-tests/macros.h
 
 Depends-on:
 array-mergesort
diff --git a/modules/sh-quote-tests b/modules/sh-quote-tests
index 1d72a1899d..b2eccc58c7 100644
--- a/modules/sh-quote-tests
+++ b/modules/sh-quote-tests
@@ -1,6 +1,5 @@
 Files:
 tests/test-sh-quote.c
-tests/macros.h
 
 Depends-on:
 
diff --git a/modules/unigbrk/u16-grapheme-breaks-tests b/modules/unigbrk/u16-grapheme-breaks-tests
index 4051d3cdea..9f7f2dffef 100644
--- a/modules/unigbrk/u16-grapheme-breaks-tests
+++ b/modules/unigbrk/u16-grapheme-breaks-tests
@@ -1,6 +1,5 @@
 Files:
 tests/unigbrk/test-u16-grapheme-breaks.c
-tests/macros.h
 
 Depends-on:
 
diff --git a/modules/unigbrk/u16-grapheme-next-tests b/modules/unigbrk/u16-grapheme-next-tests
index 724f37d858..a947afe3f3 100644
--- a/modules/unigbrk/u16-grapheme-next-tests
+++ b/modules/unigbrk/u16-grapheme-next-tests
@@ -1,6 +1,5 @@
 Files:
 tests/unigbrk/test-u16-grapheme-next.c
-tests/macros.h
 
 Depends-on:
 
diff --git a/modules/unigbrk/u16-grapheme-prev-tests b/modules/unigbrk/u16-grapheme-prev-tests
index 1f126032de..be62d2468a 100644
--- a/modules/unigbrk/u16-grapheme-prev-tests
+++ b/modules/unigbrk/u16-grapheme-prev-tests
@@ -1,6 +1,5 @@
 Files:
 tests/unigbrk/test-u16-grapheme-prev.c
-tests/macros.h
 
 Depends-on:
 
diff --git a/modules/unigbrk/u32-grapheme-breaks-tests b/modules/unigbrk/u32-grapheme-breaks-tests
index 50119c8b5d..4561344744 100644
--- a/modules/unigbrk/u32-grapheme-breaks-tests
+++ b/modules/unigbrk/u32-grapheme-breaks-tests
@@ -1,6 +1,5 @@
 Files:
 tests/unigbrk/test-u32-grapheme-breaks.c
-tests/macros.h
 
 Depends-on:
 
diff --git a/modules/unigbrk/u32-grapheme-next-tests b/modules/unigbrk/u32-grapheme-next-tests
index a5e5d8b887..4ed8b1f94e 100644
--- a/modules/unigbrk/u32-grapheme-next-tests
+++ b/modules/unigbrk/u32-grapheme-next-tests
@@ -1,6 +1,5 @@
 Files:
 tests/unigbrk/test-u32-grapheme-next.c
-tests/macros.h
 
 Depends-on:
 
diff --git a/modules/unigbrk/u32-grapheme-prev-tests b/modules/unigbrk/u32-grapheme-prev-tests
index ac76585b0b..0900722791 100644
--- a/modules/unigbrk/u32-grapheme-prev-tests
+++ b/modules/unigbrk/u32-grapheme-prev-tests
@@ -1,6 +1,5 @@
 Files:
 tests/unigbrk/test-u32-grapheme-prev.c
-tests/macros.h
 
 Depends-on:
 
diff --git a/modules/unigbrk/u8-grapheme-breaks-tests b/modules/unigbrk/u8-grapheme-breaks-tests
index a9e6991ce3..7d1f6d98d5 100644
--- a/modules/unigbrk/u8-grapheme-breaks-tests
+++ b/modules/unigbrk/u8-grapheme-breaks-tests
@@ -1,6 +1,5 @@
 Files:
 tests/unigbrk/test-u8-grapheme-breaks.c
-tests/macros.h
 
 Depends-on:
 
diff --git a/modules/unigbrk/u8-grapheme-next-tests b/modules/unigbrk/u8-grapheme-next-tests
index 2c676c61f1..d30709ea63 100644
--- a/modules/unigbrk/u8-grapheme-next-tests
+++ b/modules/unigbrk/u8-grapheme-next-tests
@@ -1,6 +1,5 @@
 Files:
 tests/unigbrk/test-u8-grapheme-next.c
-tests/macros.h
 
 Depends-on:
 
diff --git a/modules/unigbrk/u8-grapheme-prev-tests b/modules/unigbrk/u8-grapheme-prev-tests
index 7c830946cf..137e8464f7 100644
--- a/modules/unigbrk/u8-grapheme-prev-tests
+++ b/modules/unigbrk/u8-grapheme-prev-tests
@@ -1,6 +1,5 @@
 Files:
 tests/unigbrk/test-u8-grapheme-prev.c
-tests/macros.h
 
 Depends-on:
 
diff --git a/modules/unigbrk/uc-grapheme-breaks-tests b/modules/unigbrk/uc-grapheme-breaks-tests
index 2b0493930e..3c211ff5cb 100644
--- a/modules/unigbrk/uc-grapheme-breaks-tests
+++ b/modules/unigbrk/uc-grapheme-breaks-tests
@@ -2,7 +2,6 @@ Files:
 tests/unigbrk/test-uc-grapheme-breaks.c
 tests/unigbrk/test-uc-grapheme-breaks.sh
 tests/unigbrk/GraphemeBreakTest.txt
-tests/macros.h
 
 Depends-on:
 
diff --git a/tests/test-physmem.c b/tests/test-physmem.c
deleted file mode 100644
index 232cc86d12..0000000000
--- a/tests/test-physmem.c
+++ /dev/null
@@ -1,38 +0,0 @@
-/* Test of getting the amount of total/available physical memory.
-   Copyright (C) 2023 Free Software Foundation, Inc.
-
-   This file is free software: you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published
-   by the Free Software Foundation, either version 3 of the License,
-   or (at your option) any later version.
-
-   This file is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
-
-/* Written by Bruno Haible <bruno@clisp.org>, 2023.  */
-
-#include <config.h>
-
-#include "physmem.h"
-
-#include <stdio.h>
-
-#include "macros.h"
-
-int
-main (int argc, char *argv[])
-{
-  printf ("Total memory:     %12.f B = %6.f MiB\n",
-          physmem_total (), physmem_total () / (1024.0 * 1024.0));
-  printf ("Available memory: %12.f B = %6.f MiB\n",
-          physmem_available (), physmem_available () / (1024.0 * 1024.0));
-  ASSERT (physmem_total () >= physmem_available ());
-  ASSERT (physmem_available () >= 4 * 1024 * 1024);
-
-  return 0;
-}
diff --git a/tests/test-readlinkat.c b/tests/test-readlinkat.c
index 5a18fa3642..9b723a2d5e 100644
--- a/tests/test-readlinkat.c
+++ b/tests/test-readlinkat.c
@@ -79,7 +79,7 @@ main (void)
 
   /* Now perform some cross-directory checks.  Skip everything else on
      mingw.  */
-  if (HAVE_SYMLINK)
+  if (HAVE_SYMLINK || REPLACE_SYMLINK)
     {
       const char *contents = "don't matter!";
       ssize_t exp = strlen (contents);
